一、Linux结构目录及文件基本操作
1.新建
新建空白文件
       使用touch命令新建空白文件，关于 touch 命令，其主要作用是来更改已有文件的时间戳的（比如，最近访问时间，最近修改时间），
但其在不加任何参数的情况下，只指定一个文件名，则可以创建一个指定文件名的空白文件（不会覆盖已有同名文件），当然你也可以同时
指定该文件的时间戳。
格式：
  $  cd /需要创建文件的目录
  $  touch 文件名

新建目录
      使用 mkdir（make directories）命令可以创建一个空目录，也可同时指定创建目录的权限属性。
格式：
  $  mkdir 目录名  
      
      还可以使用-p参数，同时创建父目录（前提是不存在该父目录），如下我们同时创建一个多级目录。
格式：
  $  mkdir -p 父目录/子目录/...

2.复制
复制文件
       使用cp(copy)命令复制一个文件到指定目录。
格式：
  $  cp 文件名 目录名/.../...

复制目录
       需要在cp命令之后加上-r或者-R参数，表示递归复制。
格式：
  $  cp -r 源目录文件 目的目录

3.删除
删除文件
      使用rm（remove files or directories）命令删除一个文件：
格式：
  $  rm 文件名
（ps：有时候你会有时候你会遇到想要删除一些为只读权限的文件，直接使用 rm 删除会出现提示。你如果想
忽略提示，直接删除文件，可以使用-f参数强制删除：
  $  rm -f 文件名

删除目录
       和复制目录一样，要删除一个目录的话，也需要加上-r或者-R参数：
格式：
  $  rm -r/R 目录名

4.移动文件与文件重命名
移动文件
      使用mv（move or rename files）命令移动文件（剪切）。
格式：
  $  mv 源目录文件 目的目录

重命名文件
格式：
  $  mv 旧的文件名 新的文件名

批量重命名
      要实现批量重命名，mv 命令就有点力不从心了，我们可以使用一个看起来更专业的命令 rename 来实现。不过它要用 perl
正则表达式来作为参数。

5.查看文件
使用cat，tac和nl命令查看文件。
      前两个命令都是用来打印文件内容到标准输出（终端），其中 cat 为正序显示，tac 为倒序显示。
      标准输入输出：当我们执行一个 shell 命令行时通常会自动打开三个标准文件，即标准输入文件（stdin），默认对应终端的键盘、
标准输出文件（stdout）和标准错误输出文件（stderr），后两个文件都对应被重定向到终端的屏幕，以便我们能直接看到输出内容。
进程将从标准输入文件中得到输入数据，将正常输出数据输出到标准输出文件，而将错误信息送到标准错误文件中。
格式：
  $  cd 需要查看文件所在目录
  $  cat/tac 需要查看的文件名
(ps:也可加上 -n 参数显示行号,tac无法使用-n参数。）
  $  cat -n 文件名

      nl 命令，添加行号并打印，这是个比 cat -n 更专业的行号打印命令。
这里简单列举它的常用的几个参数：
-b : 指定添加行号的方式，主要有两种：
    -b a:表示无论是否为空行，同样列出行号("cat -n"就是这种方式)
    -b t:只列出非空行的编号并列出（默认为这种方式）
-n : 设置行号的样式，主要有三种：
    -n ln:在行号字段最左端显示
    -n rn:在行号字段最右边显示，且不加 0
    -n rz:在行号字段最右边显示，且加 0
-w : 行号字段占用的位数(默认为 6 位)

使用more和less命令分页查看文件
      这两个命令，那些性子比较急的人应该会喜欢，因为它们一个是只查看文件的头几行（默认为 10 行，不足 10 行则显示全部）和尾几行。
格式：
  $  tail 目录名/文件名
  也可以只看一行，加上-n参数，后面紧跟行数：
  $  tail -n 行数 /目录名/文件名

6.查看文件类型
      在 Linux 中文件的类型不是根据文件后缀来判断的，我们通常使用 file 命令查看文件的类型：
格式：file /目录名/文件名

7.编辑文件

二、文件打包与解压缩
1.zip：
   打包：zip -r -q -o 打包输出文件名.zip 需要打包的文件(目录请加-r参数)
       上面命令将目录 /home/shiyanlou/Desktop 打包成一个文件，并查看了打包后文件的大小和类型。
第一行命令中，-r 参数表示递归打包包含子目录的全部内容，-q 参数表示为安静模式，即不向屏幕输出信息，
-o，表示输出文件，需在其后紧跟打包输出文件名。后面使用 du 命令查看打包后文件的大小（后面会具体说明该命令）。
   解包：unzip 文件名.zip
   指定路径：-d 参数
   设置压缩级别为9和1（9最大，1最小），重新打包：
      $  zip -r -9 -q -o 文件名.zip 需要压缩的文件 -x ~/*.zip
   这里添加了一个参数用于设置压缩级别 -[1-9]，1 表示最快压缩但体积大，9 表示体积最小但耗时最久。
最后那个 -x 是为了排除我们上一次创建的 zip 文件，否则又会被打包进这一次的压缩文件中，注意：
这里只能使用绝对路径，否则不起作用。

2.使用unzip命令解压缩zip文件
   将压缩包解压到当前目录：
   $  unzip 文件名.zip
   使用安静模式，将文件解压到指定目录：（如果上述目录不存在将会自动创建）
   $  unzip -q 文件名.zip -d 目录名
   如果你不想解压只想查看压缩包的内容你可以使用 -l 参数：
   $  unzip -l 文件名.zip
   使用-O（大写字母O）参数指定编码类型：
   $  unzip -O GBK 文件名.zip

3.tar打包工具
   创建一个tar包：
   $  tar -cf 包名.tar 需要打包的文件
   上面命令中，-c 表示创建一个 tar 包文件，-f 用于指定创建的文件名，注意文件名必须紧跟在 -f 参数之后，比如不能写成 tar -fc shiyanlou.tar，
可以写成 tar -f shiyanlou.tar -c ~。你还可以加上 -v 参数以可视的的方式输出打包的文件。上面会自动去掉表示绝对路径的 /，你也可以使用 -P 保留绝对路径符。
   解包一个文件（-x参数）到指定路径的已存在目录（-c参数）：
   $  mkdir 目录名
   $  tar -xf 包名.tar  -C 目录名
   只查看不解包文件-t参数：
   $  tar -tf 包名.tar

三、文件系统操作与磁盘管理
1.查看磁盘和目录的容量
   使用df命令查看磁盘的容量
   格式:
   $  df [-h]
   接着你还会看到"1k-块"这个陌生的东西，它表示以磁盘块大小的方式显示容量，后面为相应的以块大小表示的已用和可用容量。
   
   使用du命令查看目录的容量
   格式：
   $  du [-h]
   -d参数指定查看目录的深度
   #  只查看1级目录的信息
   $  du -h -d 0 ~
   #  查看2级
   $  du -h -d 1 ~
常用参数：
du -h #同--human-readable 以K，M，G为单位，提高信息的可读性。
du -a #同--all 显示目录中所有文件的大小。
du -s #同--summarize 仅显示总计，只列出最后加总的值。

2.创建虚拟磁盘
   2.1 dd 命令简介（部分说明来自dd (Unix) wiki）
      dd命令用于转换和复制文件，不过它的复制不同于cp。之前提到过关于 Linux 的很重要的一点，一切即文件，在 Linux 上，
硬件的设备驱动（如硬盘）和特殊设备文件（如/dev/zero和/dev/random）都像普通文件一样，只是在各自的驱动程序中实现
了对应的功能，dd 也可以读取文件或写入这些文件。这样，dd也可以用在备份硬件的引导扇区、获取一定数量的随机数据或者
空数据等任务中。dd程序也可以在复制时处理数据，例如转换字节序、或在 ASCII 与 EBCDIC 编码间互换。
      dd的命令行语句与其他的 Linux 程序不同，因为它的命令行选项格式为选项=值，而不是更标准的--选项 值或-选项=值。
dd默认从标准输入中读取，并写入到标准输出中，但可以用选项if（input file，输入文件）和of（output file，输出文件）改变。

   格式：
# 输出到文件
$ dd of=test bs=10 count=1 # 或者 dd if=/dev/stdin of=test bs=10 count=1
# 输出到标准输出
$ dd if=/dev/stdin of=/dev/stdout bs=10 count=1
# 注
       在打完了这个命令后，继续在终端打字，作为你的输入
       注意：上述命令从标准输入设备读入用户输入（缺省值，所以可省略）然后输出到 test 文件，bs（block size）用于指定块大小（缺省
单位为 Byte，也可为其指定如'K'，'M'，'G'等单位），count用于指定块数量。如上图所示，我指定只读取总共 10 个字节的数据，当我输入
了“hello shiyanlou”之后加上空格回车总共 16 个字节（一个英文字符占一个字节）内容，显然超过了设定大小。使用du和cat命令看到的
写入完成文件实际内容确实只有 10 个字节（那个黑底百分号表示这里没有换行符）,而其他的多余输入将被截取并保留在标准输入。

   2.2使用dd命令创建虚拟镜像文件
   格式：
   $  dd if=/设备目录 of=文件名 bs=大小单位 count=块数量

   2.3使用mkfs命令格式化磁盘
   你可以在命令行输入sudo mkfs然后按下Tab键，你可以看到很多个以 mkfs 为前缀的命令，这些不同的后缀其实就是表示着不同的文件系统，可以用 mkfs 格式化成的文件系统。
   格式：
   $  sudo mkfs.* 文件

   2.4使用mount名令挂载磁盘到目录树
   使用mount查看主机已经挂载的文件系统：
   格式：
   $  sudo mount
   注意：输出结果中每一行表示一个设备或虚拟设备,每一行最前面是设备名，然后是 on 后面是挂载点，type 后面表示文件系统类型，
再后面是挂载选项（比如可以在挂载时设定以只读方式挂载等等）。

   挂载真正的磁盘到目录树，mount命令的格式如下：
   $  mount [options] [source] [directory]
   一些常用的操作：
   $  mount [-o [操作选项]] [-t 文件系统类型] [-w|--rw|--ro] [文件系统源] [挂载点]
   例如： $  mount -o loop -t ext4 virtual.img /mnt

   使用umount命令卸载已挂载磁盘
   格式：
   $  sudo umount /mnt
   
   2.5使用fdisk为磁盘分区
   查看硬盘分区表信息：
   格式：
   $  sudo fdisk -l

   进入磁盘分区模式：
   格式：
   $  sudo fdisk 文件
   
   2.6使用losetup命令建立镜像与回环设备的关联
   格式：
   $  sudo losetup 设备名 文件名
   # 如果提示设备忙你也可以使用其它的回环设备，"ls /dev/loop*"参看所有回环设备

   解除设备关联
   格式：
   $  sudo losetup -d 设备名
   
   然后在使用mkfs格式化各分区，格式化之前，需要为各分区建立虚拟设备的映射，用到kpartx工具，需要安装：
   代码：
   $  sudo apt-get install kpartx
   $  sudo kpartx -av /dev/loop0
   #取消映射
   $  sudo kpartx -dv /dev/loop0
   接着再是格式化，我们将其全部格式化为 ext4：
   $ sudo mkfs.ext4 -q /dev/mapper/loop0p1
   $ sudo mkfs.ext4 -q /dev/mapper/loop0p5
   $ sudo mkfs.ext4 -q /dev/mapper/loop0p6

   格式化完成后在/media目录下新建四个空目录用于挂载虚拟磁盘：
   代码：
   $  mkdir -p /media/virtualdisk_{1..3}

   # 挂载磁盘分区
   $ sudo mount /dev/mapper/loop0p1 /media/virtualdisk_1
   $ sudo mount /dev/mapper/loop0p5 /media/virtualdisk_2
   $ sudo mount /dev/mapper/loop0p6 /media/virtualdisk_3

   # 卸载磁盘分区
   $ sudo umount /dev/mapper/loop0p1
   $ sudo umount /dev/mapper/loop0p5
   $ sudo umount /dev/mapper/loop0p6

   然后：
   $  df -h

四、Linux任务计划crontab
1.crontab简介：
      crontab 命令从输入设备读取指令，并将其存放于 crontab 文件中，以供之后读取和执行。通常，crontab 
储存的指令被守护进程激活，crond 为其守护进程，crond 常常在后台运行，每一分钟会检查一次是否有预定的
作业需要执行。
      通过 crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell　script 脚本。时间间隔的单位
可以是分钟、小时、日、月、周的任意组合。

2.crontab准备：
手动启动crontab的代码：$  sudo cron -f &

3.crontab使用：
格式：
crontab -e
查看更详细的crontab代码：man crontab
       在了解命令格式之后，我们通过这样的一个例子来完成一个任务的添加，在文档的最后一排加上这样一排命令,该
任务是每分钟我们会在/home/shiyanlou目录下创建一个以当前的年月日时分秒为名字的空白文件，代码如下：
1 * * * * touch /home/shiyanlou/$(date +\%Y\%m\%d\%H\%M\%S)
这五个*分别是 minute(0 - 59) 
                      hour(0 - 23) 
	      day of month(1 - 31) 
	      month(1 - 12) OR jan,feb,mar,apr ...
                      day of week(0 - 6) (Sunday = 0 or 7) OR sun,mon,tue,wed,thu,fri,sat

如何查看我们添加的crontab任务：
代码：
crontab -l

如何查看我们添加的crontab任务是否在后台启动：
代码:
ps aux | grep cron 或者 pgrep cron

我们通过这样一个命令可以查看到执行任务命令之后在日志中的信息反馈
sudo tail -f /var/log/syslog

当我们并不需要这个任务的时候我们可以使用这么一个命令去删除任务
crontab -r

五、命令执行顺序控制与管道
1.有选择的执行命令
      如果我们在让它自动顺序执行命令时，前面的命令执行不成功，而后面的命令又依赖于上一条命令的结果，那么就会造成花了时间，
最终却得到一个错误的结果，而且有时候直观的看你还无法判断结果是否正确。那么我们需要能够有选择性的来执行命令，比如上一
条命令执行成功才继续下一条，或者不成功又该做出其它什么处理,比如我们使用which来查找是否安装某个命令，如果找到就执行该
命令，否则什么也不做（虽然这个操作没有什么实际意义，但可帮你更好的理解一些概念）。
  例子：
  $  which cowsay>/dev/null && cowsay -f head-in ohch~
      你如果没有安装cowsay，你可以先执行一次上述命令，你会发现什么也没发生，你再安装好之后你再执行一次上述命令，你也会发现一些惊喜。
     上面的&&就是用来实现选择性执行的，它表示如果前面的命令执行结果（不是表示终端输出的内容，而是表示命令执行状态的结果）
返回0则执行后面的，否则不执行。
      学习过 C 语言的用户应该知道在 C 语言里面&&表示逻辑与，而且还有一个||表示逻辑或，同样 Shell 也有一个||，它们的区别就在于，
shell中的这两个符号除了也可用于表示逻辑与和或之外，就是可以实现这里的命令执行顺序的简单控制。||在这里就是与&&相反的控制效果，
当上一条命令执行结果为≠0($?≠0)时则执行它后面的命令：
  $ which cowsay>/dev/null || echo "cowsay has not been install, please run 'sudo apt-get install cowsay' to install"
      除了上述基本的使用之外，我们还可以结合着&&和||来实现一些操作，比如：
  $ which cowsay>/dev/null && echo "exist" || echo "not exist"

2.管道
      管道是什么？
      管道是一种通信机制，通常用于进程间的通信（也可通过socket进行网络通信），它表现出来的形式就是将前面每一个进程的输出(stdout)
直接作为下一个进程的输入(stdin)。
       管道又分为匿名管道和具名管道（这里将不会讨论在源程序中使用系统调用创建并使用管道的情况，它与命令行的管道在内核中实际都是采
用相同的机制）。我们在使用一些过滤程序时经常会用到的就是匿名管道，在命令行中由|分隔符表示，|在前面的内容中我们已经多次使用到了。
具名管道简单的说就是有名字的管道，通常只会在源程序中用到具名管道。下面我们就将通过一些常用的可以使用管道的"过滤程序"来帮助你熟
练管道的使用。
       试用：
比如查看/etc目录下有哪些文件和目录，使用ls命令来查看：
  $ ls -al /etc
有太多内容，屏幕不能完全显示，这时候可以使用滚动条或快捷键滚动窗口来查看。不过这时候可以使用管道：
  $ ls -al /etc | less
通过管道将前一个命令(ls)的输出作为下一个命令(less)的输入，然后就可以一行一行地看。

3.cut命令（打印每一行的某一片段）
例子：
       打印/etc/passwd文件中以:为分隔符的第1个字段和第6个字段分别表示用户名和其家目录：
$ cut /etc/passwd -d ':' -f 1,6
       打印/etc/passwd文件中每一行的前N个字符：
  # 前五个（包含第五个）
  $ cut /etc/passwd -c -5
  # 前五个之后的（包含第五个）
  $ cut /etc/passwd -c 5-
  # 第五个
  $ cut /etc/passwd -c 5
  # 2到5之间的（包含第五个）
  $ cut /etc/passwd -c 2-5

4.grep命令（在文本中或stdin中查找匹配字符串）
       grep命令是很强大的，也是相当常用的一个命令，它结合正则表达式可以实现很复杂却很高效的匹配和查找，不过在学习正则表达式之前，
这里介绍它简单的使用，而关于正则表达式后面将会有单独一小节介绍到时会再继续学习grep命令和其他一些命令。
       grep命令的一般形式为：
  grep [命令选项]... 用于匹配的表达式 [文件]...
       还是先体验一下，我们搜索/home/shiyanlou目录下所有包含"shiyanlou"的文本文件，并显示出现在文本中的行号：
  $ grep -rnI "shiyanlou" ~
       -r 参数表示递归搜索子目录中的文件,-n表示打印匹配项行号，-I表示忽略二进制文件。这个操作实际没有多大意义，但可以感受到grep命令
的强大与实用。
      当然也可以在匹配字段中使用正则表达式，下面简单的演示：
  # 查看环境变量中以"yanlou"结尾的字符串
  $ export | grep ".*yanlou$"
      其中$就表示一行的末尾。

5.wc命令（简单小巧的计数工具）
      wc 命令用于统计并输出一个文件中行、单词和字节的数目，比如输出/etc/passwd文件的统计信息：
  $ wc /etc/passwd
      分别只输出行数、单词数、字节数、字符数和输入文本中最长一行的字节数：
  # 行数
  $ wc -l /etc/passwd
  # 单词数
  $ wc -w /etc/passwd
  # 字节数
  $ wc -c /etc/passwd
  # 字符数
  $ wc -m /etc/passwd
  # 最长行字节数
  $ wc -L /etc/passwd
       注意：对于西文字符来说，一个字符就是一个字节，但对于中文字符一个汉字是大于2个字节的，具体数目是由字符编码决定的
       再来结合管道来操作一下，下面统计 /etc 下面所有目录数：
  $ ls -dl /etc/*/ | wc -l

6.sort排序命令
      这个命令前面我们也是用过多次，功能很简单就是将输入按照一定方式排序，然后再输出,它支持的排序有按字典排序,数字排序，
按月份排序，随机排序，反转排序，指定特定字段进行排序等等。
      默认为字典排序：
  $ cat /etc/passwd | sort
      反转排序：
  $ cat /etc/passwd | sort -r
      按特定字段排序：
  $ cat /etc/passwd | sort -t':' -k 3
      上面的-t参数用于指定字段的分隔符，这里是以":"作为分隔符；-k 字段号用于指定对哪一个字段进行排序。这里/etc/passwd文件
的第三个字段为数字，默认情况下是以字典序排序的，如果要按照数字排序就要加上-n参数：
  $ cat /etc/passwd | sort -t':' -k 3 -n

7.uniq去重命令
      uniq命令可以用于过滤或者输出重复行。
      我们可以使用history命令查看最近执行过的命令（实际为读取${SHELL}_history文件,如我们环境中的~/.zsh_history文件），不过你
可能只想查看使用了哪个命令而不需要知道具体干了什么，那么你可能就会要想去掉命令后面的参数然后去掉重复的命令：
  $ history | cut -c 8- | cut -d ' ' -f 1 | uniq
       然后经过层层过滤，你会发现确是只输出了执行的命令那一列，不过去重效果好像不明显，仔细看你会发现它确实去重了，只是不那
么明显，之所以不明显是因为uniq命令只能去连续重复的行，不是全文去重，所以要达到预期效果，我们先排序：
  $ history | cut -c 8- | cut -d ' ' -f 1 | sort | uniq
  # 或者$ history | cut -c 8- | cut -d ' ' -f 1 | sort -u
       这就是 Linux/UNIX 哲学吸引人的地方，大繁至简，一个命令只干一件事却能干到最好。
       输出重复行
  # 输出重复过的行（重复的只输出一个）及重复次数
  $ history | cut -c 8- | cut -d ' ' -f 1 | sort | uniq -dc
  # 输出所有重复的行
  $ history | cut -c 8- | cut -d ' ' -f 1 | sort | uniq -Dca